alias func_num R1;
if (func_num == GET_FREE_PAGE) then
	alias pid R2;
	alias free_page R0;
	pid = [SYSTEM_STATUS_TABLE + 1];

	[SYSTEM_STATUS_TABLE + 3]  = [SYSTEM_STATUS_TABLE + 3] + 1;
	while ([SYSTEM_STATUS_TABLE + 2] == 0) do
		[PROCESS_TABLE + 16*pid + 4] = WAIT_MEM;
		multipush(R0, R1, R2);
		call MOD_5;
		multipop(R0, R1, R2);
	endwhile;
	[SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] - 1;
	[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;
	free_page = 0;
	while (free_page < NUM_MEM_PAGES) do
		if ([MEMORY_FREE_LIST + free_page] == 0) then
			break;
		endif;
		free_page  = free_page + 1;
	endwhile;
	[MEMORY_FREE_LIST + free_page] = 1;
	return;
endif;
if (func_num == RELEASE_PAGE) then
	alias pgno R2;
	if ([MEMORY_FREE_LIST + pgno] > 0) then
		[MEMORY_FREE_LIST + pgno] = [MEMORY_FREE_LIST + pgno] - 1;
	endif;
	if ([MEMORY_FREE_LIST + pgno] == 0) then
		[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] + 1;
	endif;
	alias i R0;
	while (i < MAX_PROC_NUM) do
		if ([PROCESS_TABLE + 16*i + 1] >= 0 && [PROCESS_TABLE + 16*i + 4] == WAIT_MEM) then
			[PROCESS_TABLE + 16*i + 4] = READY;
		endif;
	endwhile;
	R0 = 0;
	return;
endif;
